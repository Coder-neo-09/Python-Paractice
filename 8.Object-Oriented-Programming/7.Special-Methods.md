# 🏗️ 8.7 Special (Dunder) Methods (`__str__`, `__len__`, etc.)

Python provides **special methods** (also called **dunder methods**) that start and end with double underscores (`__`).
They allow you to **customize built-in behavior** of objects.

---

## 🔑 Common Dunder Methods

| Method     | Purpose                                    |
| ---------- | ------------------------------------------ |
| `__init__` | Constructor, initializes object            |
| `__str__`  | String representation (used by `print()`)  |
| `__repr__` | Official string representation (debugging) |
| `__len__`  | Returns length (used by `len()`)           |
| `__add__`  | Defines behavior for `+` operator          |
| `__eq__`   | Defines behavior for `==` comparison       |

---

## 📌 Example 1: `__str__`

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        return f"{self.name}, {self.age} years old"

p = Person("Alice", 25)
print(p)  # Alice, 25 years old
```

✅ Makes printing objects readable.

---

## 📌 Example 2: `__len__`

```python
class Team:
    def __init__(self, members):
        self.members = members

    def __len__(self):
        return len(self.members)

team = Team(["Alice", "Bob", "Charlie"])
print(len(team))  # 3
```

✅ Lets objects work with `len()`.

---

## 📌 Example 3: `__add__`

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)

    def __str__(self):
        return f"({self.x}, {self.y})"

p1 = Point(2, 3)
p2 = Point(4, 5)
print(p1 + p2)  # (6, 8)
```

✅ Customizes operator behavior.

---

## 🎯 Mini Project: Product Inventory

```python
class Product:
    def __init__(self, name, price, quantity):
        self.name = name
        self.price = price
        self.quantity = quantity

    def __str__(self):
        return f"{self.name}: ${self.price} ({self.quantity} in stock)"

    def __len__(self):
        return self.quantity

    def __eq__(self, other):
        return self.name == other.name and self.price == other.price

p1 = Product("Laptop", 1200, 5)
p2 = Product("Laptop", 1200, 3)

print(p1)            # Laptop: $1200 (5 in stock)
print(len(p1))       # 5
print(p1 == p2)      # True
```

✅ Shows how dunder methods make objects **interactable like built-in types**.

---

## 🧠 Best Practices

* Use dunder methods to **make your objects behave naturally**
* Implement only necessary methods to **avoid complexity**
* Keep behavior **intuitive** for operators and functions
