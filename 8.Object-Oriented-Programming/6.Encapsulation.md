# 🏗️ 8.6 Encapsulation

Encapsulation is the concept of **hiding the internal details** of an object and **restricting direct access** to its attributes.
It helps to **protect data** and maintain **control over how attributes are modified**.

---

## 🔑 Types of Encapsulation in Python

1. **Public Attributes** → accessible from anywhere (`self.name`)
2. **Protected Attributes** → should not be accessed outside class (`_name`)
3. **Private Attributes** → cannot be accessed directly outside class (`__name`)

---

## 📌 Example 1: Public Attributes

```python
class Person:
    def __init__(self, name):
        self.name = name  # public

p = Person("Alice")
print(p.name)  # Alice
p.name = "Bob"
print(p.name)  # Bob
```

✅ Anyone can access or modify public attributes.

---

## 📌 Example 2: Protected Attributes

```python
class Person:
    def __init__(self, name):
        self._name = name  # protected

p = Person("Alice")
print(p._name)  # accessible, but by convention should not be modified outside
```

✅ Protected is a **convention**, not enforced by Python.

---

## 📌 Example 3: Private Attributes

```python
class Person:
    def __init__(self, name):
        self.__name = name  # private

    def get_name(self):
        return self.__name

    def set_name(self, name):
        self.__name = name

p = Person("Alice")
# print(p.__name)  # ❌ AttributeError
print(p.get_name())  # Alice
p.set_name("Bob")
print(p.get_name())  # Bob
```

✅ Private attributes are accessed via **getter/setter methods**.

---

## 🎯 Mini Project: Bank Account with Encapsulation

```python
class BankAccount:
    def __init__(self, owner, balance):
        self.owner = owner
        self.__balance = balance  # private

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            print(f"Deposited {amount}. New balance: {self.__balance}")
        else:
            print("Invalid deposit amount!")

    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            print(f"Withdrawn {amount}. Remaining balance: {self.__balance}")
        else:
            print("Insufficient funds or invalid amount!")

    def get_balance(self):
        return self.__balance

# Test
acc = BankAccount("Alice", 1000)
acc.deposit(500)
acc.withdraw(200)
print("Balance:", acc.get_balance())
```

✅ Output:

```
Deposited 500. New balance: 1500
Withdrawn 200. Remaining balance: 1300
Balance: 1300
```

---

## 🧠 Best Practices

* Use **private attributes** for sensitive data
* Provide **getter and setter methods** to control access
* Avoid exposing internal implementation details
* Encapsulation improves **security** and **maintainability**
