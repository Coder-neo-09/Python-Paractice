# 🏗️ 8.5 Polymorphism

Polymorphism means **“many forms”**. In Python, it allows **different objects to respond to the same method in different ways**.

---

## 🔑 Types of Polymorphism

1. **Method Overriding** – Child class provides a **different implementation** of a parent method.
2. **Operator Overloading** – Same operator works **differently for different data types**.
3. **Duck Typing** – “If it walks like a duck and quacks like a duck, it’s a duck” → different objects can be used interchangeably if they implement the required methods.

---

## 📌 Example 1: Method Overriding

```python
class Animal:
    def speak(self):
        print("Animal speaks")

class Dog(Animal):
    def speak(self):
        print("Dog barks")

class Cat(Animal):
    def speak(self):
        print("Cat meows")

animals = [Dog(), Cat()]
for a in animals:
    a.speak()
```

Output:

```
Dog barks
Cat meows
```

✅ Same method name, different behavior.

---

## 📌 Example 2: Operator Overloading

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)

    def __str__(self):
        return f"({self.x}, {self.y})"

p1 = Point(2, 3)
p2 = Point(4, 5)
print(p1 + p2)  # (6, 8)
```

✅ Same `+` operator, works differently for `Point` objects.

---

## 📌 Example 3: Duck Typing

```python
class Bird:
    def fly(self):
        print("Bird is flying")

class Airplane:
    def fly(self):
        print("Airplane is flying")

def lets_fly(flyer):
    flyer.fly()

lets_fly(Bird())      # Bird is flying
lets_fly(Airplane())  # Airplane is flying
```

✅ Function works with **any object** that implements `fly()`.

---

## 🎯 Mini Project: Shape Area Calculator

```python
class Shape:
    def area(self):
        pass

class Rectangle(Shape):
    def __init__(self, w, h):
        self.w = w
        self.h = h
    def area(self):
        return self.w * self.h

class Circle(Shape):
    def __init__(self, r):
        self.r = r
    def area(self):
        return 3.14 * self.r ** 2

shapes = [Rectangle(5, 3), Circle(4)]
for s in shapes:
    print("Area:", s.area())
```

Output:

```
Area: 15
Area: 50.24
```

✅ Same `area()` method behaves differently for different shapes.

---

## 🧠 Best Practices

* Use polymorphism to **simplify code** and **increase flexibility**
* Prefer **duck typing** for lightweight code
* Method overriding should **preserve intended behavior**
* Operator overloading should be **intuitive**
