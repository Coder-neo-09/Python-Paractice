# ðŸ”„ 9.1 Iterators & Generators

Python provides tools to **iterate over data efficiently**.

* **Iterator** â†’ object that can be iterated (using `next()`)
* **Generator** â†’ a special iterator that **yields values on the fly** (memory efficient)

---

## ðŸ”‘ 1. Iterators

* Any object that implements `__iter__()` and `__next__()` is an iterator.
* You can use `iter()` and `next()` to iterate manually.

```python
my_list = [1, 2, 3]
it = iter(my_list)

print(next(it))  # 1
print(next(it))  # 2
print(next(it))  # 3
# print(next(it))  # StopIteration error
```

âœ… Loops like `for` automatically handle StopIteration.

---

## ðŸ”‘ 2. Generators

* Use `yield` instead of `return` to produce values one at a time.
* Very **memory-efficient** for large datasets.

```python
def squares(n):
    for i in range(n):
        yield i ** 2

gen = squares(5)
for val in gen:
    print(val)
```

Output:

```
0
1
4
9
16
```

âœ… Values are generated **on demand**, not stored in memory.

---

## ðŸ”‘ 3. Generator Expression

* Similar to list comprehension, but **lazy**.

```python
gen_exp = (x**2 for x in range(5))
print(next(gen_exp))  # 0
print(next(gen_exp))  # 1
```

---

## ðŸŽ¯ Mini Project: Fibonacci Generator

```python
def fibonacci(n):
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

for num in fibonacci(10):
    print(num)
```

Output:

```
0 1 1 2 3 5 8 13 21 34
```

âœ… Generates Fibonacci numbers **efficiently without storing the full list**.

---

## ðŸ§  Best Practices

* Use **iterators** for custom iteration logic
* Use **generators** for memory-efficient large data handling
* Avoid storing huge lists if **generator can yield values**
* Combine generators with loops or comprehensions for clean code
